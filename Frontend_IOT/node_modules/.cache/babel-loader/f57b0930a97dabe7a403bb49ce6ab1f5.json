{"ast":null,"code":"import { createMat4 } from './math-utils';\nimport { zoomToScale, pixelsToWorld, lngLatToWorld, worldToLngLat, worldToPixels, altitudeToFovy, fovyToAltitude, DEFAULT_ALTITUDE, getProjectionMatrix, getDistanceScales, getViewMatrix } from './web-mercator-utils';\nimport fitBounds from './fit-bounds';\nimport getBounds from './get-bounds';\nimport * as mat4 from 'gl-matrix/mat4';\nimport * as vec2 from 'gl-matrix/vec2';\nimport * as vec3 from 'gl-matrix/vec3';\nexport default class WebMercatorViewport {\n  constructor() {\n    let {\n      width,\n      height,\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      altitude = null,\n      fovy = null,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      width: 1,\n      height: 1\n    };\n    width = width || 1;\n    height = height || 1;\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n    const scale = zoomToScale(zoom);\n    altitude = Math.max(0.75, altitude);\n    const distanceScales = getDistanceScales({\n      longitude,\n      latitude\n    });\n    const center = lngLatToWorld([longitude, latitude]);\n    center[2] = 0;\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n    this.distanceScales = distanceScales;\n    this._initMatrices();\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    Object.freeze(this);\n  }\n  _initMatrices() {\n    const {\n      width,\n      height,\n      projectionMatrix,\n      viewMatrix\n    } = this;\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    const m = createMat4();\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n    const mInverse = mat4.invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n  equals(viewport) {\n    if (!(viewport instanceof WebMercatorViewport)) {\n      return false;\n    }\n    return viewport.width === this.width && viewport.height === this.height && mat4.equals(viewport.projectionMatrix, this.projectionMatrix) && mat4.equals(viewport.viewMatrix, this.viewMatrix);\n  }\n  project(xyz) {\n    let {\n      topLeft = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n  unproject(xyz) {\n    let {\n      topLeft = true,\n      targetZ = undefined\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const [x, y, z] = xyz;\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n  projectPosition(xyz) {\n    const [X, Y] = lngLatToWorld(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n  unprojectPosition(xyz) {\n    const [X, Y] = worldToLngLat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n  projectFlat(lngLat) {\n    return lngLatToWorld(lngLat);\n  }\n  unprojectFlat(xy) {\n    return worldToLngLat(xy);\n  }\n  getMapCenterByLngLatPosition(_ref) {\n    let {\n      lngLat,\n      pos\n    } = _ref;\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return worldToLngLat(newCenter);\n  }\n  getLocationAtPoint(_ref2) {\n    let {\n      lngLat,\n      pos\n    } = _ref2;\n    return this.getMapCenterByLngLatPosition({\n      lngLat,\n      pos\n    });\n  }\n  fitBounds(bounds) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      width,\n      height\n    } = this;\n    const {\n      longitude,\n      latitude,\n      zoom\n    } = fitBounds(Object.assign({\n      width,\n      height,\n      bounds\n    }, options));\n    return new WebMercatorViewport({\n      width,\n      height,\n      longitude,\n      latitude,\n      zoom\n    });\n  }\n  getBounds(options) {\n    const corners = this.getBoundingRegion(options);\n    const west = Math.min(...corners.map(p => p[0]));\n    const east = Math.max(...corners.map(p => p[0]));\n    const south = Math.min(...corners.map(p => p[1]));\n    const north = Math.max(...corners.map(p => p[1]));\n    return [[west, south], [east, north]];\n  }\n  getBoundingRegion() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return getBounds(this, options.z || 0);\n  }\n}","map":{"version":3,"mappings":"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","names":["createMat4","zoomToScale","pixelsToWorld","lngLatToWorld","worldToLngLat","worldToPixels","altitudeToFovy","fovyToAltitude","DEFAULT_ALTITUDE","getProjectionMatrix","getDistanceScales","getViewMatrix","fitBounds","getBounds","mat4","vec2","vec3","WebMercatorViewport","constructor","width","height","latitude","longitude","zoom","pitch","bearing","altitude","fovy","position","nearZMultiplier","farZMultiplier","scale","Math","max","distanceScales","center","add","mul","unitsPerMeter","projectionMatrix","viewMatrix","meterOffset","_initMatrices","equals","bind","project","unproject","projectPosition","unprojectPosition","Object","freeze","vpm","multiply","viewProjectionMatrix","m","translate","mInverse","invert","Error","pixelProjectionMatrix","pixelUnprojectionMatrix","viewport","xyz","topLeft","worldPosition","coord","x","y","y2","length","targetZ","undefined","z","targetZWorld","X","Y","Z","Number","isFinite","metersPerUnit","projectFlat","lngLat","unprojectFlat","xy","getMapCenterByLngLatPosition","pos","fromLocation","toLocation","negate","newCenter","getLocationAtPoint","bounds","options","assign","corners","getBoundingRegion","west","min","map","p","east","south","north"],"sources":["../../src/web-mercator-viewport.js"],"sourcesContent":["// View and Projection Matrix calculations for mapbox-js style map view properties\nimport {createMat4} from './math-utils';\n\nimport {\n  zoomToScale,\n  pixelsToWorld,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  altitudeToFovy,\n  fovyToAltitude,\n  DEFAULT_ALTITUDE,\n  getProjectionMatrix,\n  getDistanceScales,\n  getViewMatrix\n} from './web-mercator-utils';\nimport fitBounds from './fit-bounds';\nimport getBounds from './get-bounds';\n\nimport * as mat4 from 'gl-matrix/mat4';\nimport * as vec2 from 'gl-matrix/vec2';\nimport * as vec3 from 'gl-matrix/vec3';\n\nexport default class WebMercatorViewport {\n  // eslint-disable-next-line max-statements\n  constructor(\n    {\n      // Map state\n      width,\n      height,\n      latitude = 0,\n      longitude = 0,\n      zoom = 0,\n      pitch = 0,\n      bearing = 0,\n      altitude = null,\n      fovy = null,\n      position = null,\n      nearZMultiplier = 0.02,\n      farZMultiplier = 1.01\n    } = {width: 1, height: 1}\n  ) {\n    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n    width = width || 1;\n    height = height || 1;\n\n    // `fovy` & `altitude` are independent parameters, one for the\n    // projection and the latter for the view matrix. In the past,\n    // the `fovy` was always derived from the `altitude`\n    if (fovy === null && altitude === null) {\n      altitude = DEFAULT_ALTITUDE;\n      fovy = altitudeToFovy(altitude);\n    } else if (fovy === null) {\n      fovy = altitudeToFovy(altitude);\n    } else if (altitude === null) {\n      altitude = fovyToAltitude(fovy);\n    }\n\n    const scale = zoomToScale(zoom);\n    // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n    altitude = Math.max(0.75, altitude);\n\n    const distanceScales = getDistanceScales({longitude, latitude});\n\n    const center = lngLatToWorld([longitude, latitude]);\n    center[2] = 0;\n\n    if (position) {\n      vec3.add(center, center, vec3.mul([], position, distanceScales.unitsPerMeter));\n    }\n\n    this.projectionMatrix = getProjectionMatrix({\n      width,\n      height,\n      pitch,\n      fovy,\n      nearZMultiplier,\n      farZMultiplier\n    });\n\n    this.viewMatrix = getViewMatrix({\n      height,\n      scale,\n      center,\n      pitch,\n      bearing,\n      altitude\n    });\n\n    // Save parameters\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n\n    this.latitude = latitude;\n    this.longitude = longitude;\n    this.zoom = zoom;\n    this.pitch = pitch;\n    this.bearing = bearing;\n    this.altitude = altitude;\n    this.fovy = fovy;\n    this.center = center;\n    this.meterOffset = position || [0, 0, 0];\n\n    this.distanceScales = distanceScales;\n\n    this._initMatrices();\n\n    // Bind methods for easy access\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n\n    Object.freeze(this);\n  }\n\n  _initMatrices() {\n    const {width, height, projectionMatrix, viewMatrix} = this;\n\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, projectionMatrix);\n    mat4.multiply(vpm, vpm, viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // Calculate matrices and scales needed for projection\n    /**\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n    const m = createMat4();\n\n    // matrix for conversion from location to screen coordinates\n    mat4.scale(m, m, [width / 2, -height / 2, 1]);\n    mat4.translate(m, m, [1, -1, 0]);\n    mat4.multiply(m, m, vpm);\n\n    const mInverse = mat4.invert(createMat4(), m);\n    if (!mInverse) {\n      throw new Error('Pixel project matrix not invertible');\n    }\n\n    this.pixelProjectionMatrix = m;\n    this.pixelUnprojectionMatrix = mInverse;\n  }\n\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport) {\n    if (!(viewport instanceof WebMercatorViewport)) {\n      return false;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      mat4.equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      mat4.equals(viewport.viewMatrix, this.viewMatrix)\n    );\n  }\n\n  // Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n  // using viewport projection parameters\n  project(xyz, {topLeft = true} = {}) {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  // Unproject pixel coordinates on screen onto world coordinates,\n  // (possibly [lon, lat]) on map.\n  unproject(xyz, {topLeft = true, targetZ = undefined} = {}) {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition(xyz) {\n    const [X, Y] = lngLatToWorld(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz) {\n    const [X, Y] = worldToLngLat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  // Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n  projectFlat(lngLat) {\n    return lngLatToWorld(lngLat);\n  }\n\n  // Unproject world point [x,y] on map onto {lat, lon} on sphere\n  unprojectFlat(xy) {\n    return worldToLngLat(xy);\n  }\n\n  // Get the map center that place a given [lng, lat] coordinate at screen point [x, y]\n  getMapCenterByLngLatPosition({lngLat, pos}) {\n    const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);\n    const toLocation = lngLatToWorld(lngLat);\n\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n\n    return worldToLngLat(newCenter);\n  }\n\n  // Legacy method name\n  getLocationAtPoint({lngLat, pos}) {\n    return this.getMapCenterByLngLatPosition({lngLat, pos});\n  }\n\n  // Returns a new viewport that fit around the given rectangle.\n  fitBounds(bounds, options = {}) {\n    const {width, height} = this;\n    const {longitude, latitude, zoom} = fitBounds(Object.assign({width, height, bounds}, options));\n    return new WebMercatorViewport({width, height, longitude, latitude, zoom});\n  }\n\n  getBounds(options) {\n    const corners = this.getBoundingRegion(options);\n\n    const west = Math.min(...corners.map((p) => p[0]));\n    const east = Math.max(...corners.map((p) => p[0]));\n    const south = Math.min(...corners.map((p) => p[1]));\n    const north = Math.max(...corners.map((p) => p[1]));\n    return [\n      [west, south],\n      [east, north]\n    ];\n  }\n\n  getBoundingRegion(options = {}) {\n    return getBounds(this, options.z || 0);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}