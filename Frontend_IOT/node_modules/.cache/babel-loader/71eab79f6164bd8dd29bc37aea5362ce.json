{"ast":null,"code":"import { whichButtons, getOffsetPosition } from './event-utils';\nconst DEFAULT_OPTIONS = {\n  srcElement: 'root',\n  priority: 0\n};\nexport default class EventRegistrar {\n  constructor(eventManager) {\n    this.eventManager = eventManager;\n    this.handlers = [];\n    this.handlersByElement = new Map();\n    this.handleEvent = this.handleEvent.bind(this);\n    this._active = false;\n  }\n  isEmpty() {\n    return !this._active;\n  }\n  add(type, handler, opts) {\n    let once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n    if (opts && (typeof opts !== 'object' || opts.addEventListener)) {\n      opts = {\n        srcElement: opts\n      };\n    }\n    opts = opts ? Object.assign({}, DEFAULT_OPTIONS, opts) : DEFAULT_OPTIONS;\n    let entries = handlersByElement.get(opts.srcElement);\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n    const entry = {\n      type,\n      handler,\n      srcElement: opts.srcElement,\n      priority: opts.priority\n    };\n    if (once) {\n      entry.once = true;\n    }\n    if (passive) {\n      entry.passive = true;\n    }\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n    let insertPosition = entries.length - 1;\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n      insertPosition--;\n    }\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n  remove(type, handler) {\n    const {\n      handlers,\n      handlersByElement\n    } = this;\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n    this._active = handlers.some(entry => !entry.passive);\n  }\n  handleEvent(event) {\n    if (this.isEmpty()) {\n      return;\n    }\n    const mjolnirEvent = this._normalizeEvent(event);\n    let target = event.srcEvent.target;\n    while (target && target !== mjolnirEvent.rootElement) {\n      this._emit(mjolnirEvent, target);\n      if (mjolnirEvent.handled) {\n        return;\n      }\n      target = target.parentNode;\n    }\n    this._emit(mjolnirEvent, 'root');\n  }\n  _emit(event, srcElement) {\n    const entries = this.handlersByElement.get(srcElement);\n    if (entries) {\n      let immediatePropagationStopped = false;\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove = [];\n      for (let i = 0; i < entries.length; i++) {\n        const {\n          type,\n          handler,\n          once\n        } = entries[i];\n        handler(Object.assign({}, event, {\n          type,\n          stopPropagation,\n          stopImmediatePropagation\n        }));\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {\n          type,\n          handler\n        } = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n  _normalizeEvent(event) {\n    const rootElement = this.eventManager.element;\n    return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {\n      handled: false,\n      rootElement\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["whichButtons","getOffsetPosition","DEFAULT_OPTIONS","srcElement","priority","EventRegistrar","constructor","eventManager","handlers","handlersByElement","Map","handleEvent","bind","_active","isEmpty","add","type","handler","opts","once","passive","addEventListener","Object","assign","entries","get","set","entry","push","insertPosition","length","splice","remove","i","indexOf","delete","some","event","mjolnirEvent","_normalizeEvent","target","srcEvent","rootElement","_emit","handled","parentNode","immediatePropagationStopped","stopPropagation","stopImmediatePropagation","entriesToRemove","element"],"sources":["../../../src/utils/event-registrar.js"],"sourcesContent":["import {whichButtons, getOffsetPosition} from './event-utils';\n\nconst DEFAULT_OPTIONS = {\n  srcElement: 'root',\n  priority: 0\n};\n\nexport default class EventRegistrar {\n  constructor(eventManager) {\n    this.eventManager = eventManager;\n    this.handlers = [];\n    // Element -> handler map\n    this.handlersByElement = new Map();\n\n    this.handleEvent = this.handleEvent.bind(this);\n    this._active = false;\n  }\n\n  // Returns true if there are no non-passive handlers\n  isEmpty() {\n    return !this._active;\n  }\n\n  add(type, handler, opts, once = false, passive = false) {\n    const {handlers, handlersByElement} = this;\n\n    if (opts && (typeof opts !== 'object' || opts.addEventListener)) {\n      // is DOM element, backward compatibility\n      opts = {srcElement: opts};\n    }\n    opts = opts ? Object.assign({}, DEFAULT_OPTIONS, opts) : DEFAULT_OPTIONS;\n\n    let entries = handlersByElement.get(opts.srcElement);\n    if (!entries) {\n      entries = [];\n      handlersByElement.set(opts.srcElement, entries);\n    }\n    const entry = {type, handler, srcElement: opts.srcElement, priority: opts.priority};\n    if (once) {\n      entry.once = true;\n    }\n    if (passive) {\n      entry.passive = true;\n    }\n    handlers.push(entry);\n    this._active = this._active || !entry.passive;\n\n    // Sort handlers by descending priority\n    // Handlers with the same priority are excuted in the order of registration\n    let insertPosition = entries.length - 1;\n    while (insertPosition >= 0) {\n      if (entries[insertPosition].priority >= entry.priority) {\n        break;\n      }\n      insertPosition--;\n    }\n    entries.splice(insertPosition + 1, 0, entry);\n  }\n\n  remove(type, handler) {\n    const {handlers, handlersByElement} = this;\n\n    for (let i = handlers.length - 1; i >= 0; i--) {\n      const entry = handlers[i];\n\n      if (entry.type === type && entry.handler === handler) {\n        handlers.splice(i, 1);\n        const entries = handlersByElement.get(entry.srcElement);\n        entries.splice(entries.indexOf(entry), 1);\n        if (entries.length === 0) {\n          handlersByElement.delete(entry.srcElement);\n        }\n      }\n    }\n    this._active = handlers.some(entry => !entry.passive);\n  }\n\n  /**\n   * Handles hammerjs event\n   */\n  handleEvent(event) {\n    if (this.isEmpty()) {\n      return;\n    }\n\n    const mjolnirEvent = this._normalizeEvent(event);\n    let target = event.srcEvent.target;\n\n    while (target && target !== mjolnirEvent.rootElement) {\n      this._emit(mjolnirEvent, target);\n      if (mjolnirEvent.handled) {\n        return;\n      }\n      target = target.parentNode;\n    }\n    this._emit(mjolnirEvent, 'root');\n  }\n\n  /**\n   * Invoke handlers on a particular element\n   */\n  _emit(event, srcElement) {\n    const entries = this.handlersByElement.get(srcElement);\n\n    if (entries) {\n      let immediatePropagationStopped = false;\n\n      // Prevents the current event from bubbling up\n      const stopPropagation = () => {\n        event.handled = true;\n      };\n      // Prevent any remaining listeners from being called\n      const stopImmediatePropagation = () => {\n        event.handled = true;\n        immediatePropagationStopped = true;\n      };\n      const entriesToRemove = [];\n\n      for (let i = 0; i < entries.length; i++) {\n        const {type, handler, once} = entries[i];\n        handler(\n          Object.assign({}, event, {\n            type,\n            stopPropagation,\n            stopImmediatePropagation\n          })\n        );\n        if (once) {\n          entriesToRemove.push(entries[i]);\n        }\n        if (immediatePropagationStopped) {\n          break;\n        }\n      }\n\n      for (let i = 0; i < entriesToRemove.length; i++) {\n        const {type, handler} = entriesToRemove[i];\n        this.remove(type, handler);\n      }\n    }\n  }\n\n  /**\n   * Normalizes hammerjs and custom events to have predictable fields.\n   */\n  _normalizeEvent(event) {\n    const rootElement = this.eventManager.element;\n\n    return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {\n      handled: false,\n      rootElement\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}